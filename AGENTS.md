# AGENT INSTRUCTIONS

These instructions apply to the entire repository.

## Purpose and scope
This repository hosts a FastAPI backend built with Python 3.14.2. Development uses the latest FastAPI framework with async PostgreSQL access through `asyncpg`, SQLAlchemy as the ORM, and dependency management via the latest `uv` package manager.

## Environment and setup
- Use Python **3.14.2** and the **latest `uv`** as the package manager.
- Create and activate a virtual environment before installing dependencies.
- Install dependencies with `uv sync` (from `pyproject.toml`/`uv.lock`); add new dependencies with `uv add <package_name>` instead of `uv pip install`.
- Required tools for local work: Docker, Docker Compose, and Git.
- Required environment variables: `DATABASE_URL` (PostgreSQL connection string), `POSTGRES_USER`, `POSTGRES_PASSWORD`, `POSTGRES_DB`, and `APP_ENV`.
- Start PostgreSQL locally with Docker Compose or a `docker run` command, and keep migrations/seed data checked into the repo.

## Architecture
Follow a layered structure: **model layer**, **repository layer**, **service layer**, and **router layer**. Keep concerns separated and inject dependencies explicitly.

## Development workflow
- Run the app with `uvicorn <app_module>.main:app --reload` (update the module path as the project evolves).
- Use type hints throughout, Pydantic models for request/response schemas, and FastAPI `Depends` for DI.
- For database access, use SQLAlchemy models with async PostgreSQL interactions via `asyncpg`. Prefer parameterized queries and keep models/migrations organized.
- Handle errors with `HTTPException` and consistent error payloads; centralize exception handlers when possible.

## Migrations and database hygiene
- Use Alembic for migrations: `alembic revision --autogenerate -m "<message>"` and `alembic upgrade head`.
- Review autogenerated migration diffs before committing. Keep seed scripts deterministic and version-controlled.

## Testing and quality
- Run tests with `pytest`; add markers for DB-dependent tests if needed.
- Use `ruff` for linting/formatting; ensure it passes before opening a PR.
- For DB-dependent tests, spin up an ephemeral PostgreSQL instance (e.g., via Docker) and prefer transactional fixtures.

## API documentation and contracts
- Keep OpenAPI documentation current; organize routers under versioned prefixes (e.g., `/api/v1`).
- Provide response models, tags, and docstrings for routes. Maintain consistent JSON contracts.

## Security and secrets
- Never commit secrets or `.env` files. Provide defaults via `.env.example`.
- Follow best practices for password hashing and token handling. Configure CORS appropriately and avoid logging PII.

## Git and PR etiquette
- Use clear branch names and conventional commit messages.
- Ensure PRs include tests, linting results, and any required migrations.
- Summarize changes clearly in PR descriptions; include relevant commands that were run.

## Operations
- Document health/readiness checks and observability hooks (logging/metrics/tracing) when added.
- Note deployment assumptions (e.g., containerization, CI workflows) and where related files live.
